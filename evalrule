ss << "Rule Evaluation\n\n";
	int cnt = 0;
	int passes = 0;
	do //Evaluate rules at least one time
	{
		cnt = countTuples(); //Set starting tuple count
		for (vector<Rule>::iterator it = rule_list.begin(); it != rule_list.end(); ++it) //Iterate through each rule
		{
			ss << it->toString() << "\n";
			std::vector<Relation> rule_data; //Temporary vector to save new relations
			std::vector<Predicate> cur_data = it->getData(); //Temporary vector to hold rule data
			for (std::vector<Predicate>::iterator jt = cur_data.begin(); jt != cur_data.end(); ++jt) //Iterate through each predicate
			{
				rule_data.push_back(ruleRel(*jt)); //Save relations created by rule data
			}
			while (rule_data.size() > 1) //More than one new relation?
			{
				rule_data[0] = rule_data[0].join(rule_data[1]); //Join first two relations
				rule_data.erase(rule_data.begin() + 1); //Erase the second
			} //If more than one remains, repeat
			rule_data[0] = rule_data[0].project(rule_data[0].findPos(it->getHead().getParam())); //Project on the remaining relation based on the positions found from rule head
			std::string cur_name = it->getHead().getName();
			data.at(cur_name).compFacts(rule_data[0]); //Remove anything already in the relation prior to printing out
			rule_data[0] = rule_data[0].rename(data.at(cur_name).getScheme()); //Rename based on relation
			ss << rule_data[0].toString(); //Print out prior to union
			data.at(cur_name) = data.at(cur_name).onion(rule_data[0]); //Find the relation with a matching name and union with the one from evaluation
		}
		++passes; //How many times through the rules?
	} while (cnt != countTuples()); //Repeat if any relations were altered by rules
	ss << "\nConverged after " << passes << " passes through the Rules.\n\n";
	for (std::map<std::string, Relation>::iterator it = data.begin(); it != data.end(); ++it)
	{
		ss << it->first << "\n" << it->second.toString() << "\n";
	}
