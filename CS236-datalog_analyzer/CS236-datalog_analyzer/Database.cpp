/* ---------------------------------------------------------------------------
**
** Database.cpp
** Implementation of database and functions to populate it.
** 7-27-16
** Author: Nathan Finch
** -------------------------------------------------------------------------*/

#include "Database.h"

/*
	Outputs the relations and corresponding facts, sorted by vector < operator as part
	of the set class.
*/
void Database::factOut()
{
	ss << "Fact Evaluation\n\n";
	for (std::map<std::string, Relation>::iterator it = data.begin(); it != data.end(); ++it)
	{
		ss << it->second.getName() << "\n"; //Output relation name
		ss << it->second.toString(); //Output the relation facts
		ss << "\n"; //Blank line after each relation's facts
	}
}

/*
	Takes in a list of schemes created by the Datalog Program, creating an empty relation
	for each.
*/
void Database::evalSchemes(std::vector<Predicate> schm_lst)
{
	for (vector<Predicate>::iterator it = schm_lst.begin(); it != schm_lst.end(); ++it)
	{
		Relation cur_rel;
		cur_rel.setName(it->getName()); //Predicate name becomes the relation name
		cur_rel.setScheme(it->getParams()); //Paremeters are converted to strings and set as scheme
		data.emplace(it->getName(), cur_rel); //The empty relation is added to the database
	}
	ss << "Scheme Evaluation\n\n";
}

/*
	Takes in a vector of predicate facts from the Datalog Program, iterates through
	each and adds them to the relation corresponding to the fact name.
*/
void Database::evalFacts(std::vector<Predicate> fcts_lst)
{
	for (vector<Predicate>::iterator it = fcts_lst.begin(); it != fcts_lst.end(); ++it)
	{
		data.find(it->getName())->second.addFact(it->getParams()); //Find the relation by name and add the fact as a tuple.
	}
	factOut();
}

/*
	Searches a vector of parameters to see if there are multiple entries of one value,
	recording each position in a vector.
*/
vector<int> Database::findTwo(std::vector<Parameter> prms, Parameter cur_param)
{
	std::vector<int> ind;
	int i = 0;
	for (std::vector<Parameter>::iterator it = prms.begin(); it != prms.end(); ++it)
	{
		if (it->toString() == cur_param.toString())
		{
			ind.push_back(i);
		}
		++i;
	}
	return ind;
}

/*
	Check parameters for variable or constant values and select from the current
	relation tuples that match.
*/
void Database::searchSelect(Predicate cur_pred, Relation& cur_rel)
{
	int i = 0; //Count position in list to pass to select function
	vector<Parameter> params = cur_pred.getParam(); //Get the parameters of the current predicate
	for (std::vector<Parameter>::iterator it = params.begin(); it != params.end(); ++it) //Iterate over the parameter list
	{
		if (it->isLiteral()) //Constant?
		{
			cur_rel = cur_rel.select(i, it->toString()); //Add tuples with value in current index
		}
		else //Variable
		{
			vector<int> ind = findTwo(params, *it); //Check for two of the same variable
			if (ind.size() > 1) //If variable reoccurs
			{
				cur_rel = cur_rel.select(ind[0], ind[1]); //Add tuples with matching values at given positions
			}
		}
		++i; //Increment counter
	}
	
}

/*
	Takes a vector of predicates, which are queries generated by the
	Datalog Program, as input and iterates through them to create new relations
	in the database. Each new relation is based on select, project and rename
	operations as required by the query being evaluated.
*/
void Database::evalQueries(std::vector<Predicate> qrs_lst)
{
	ss << "Query Evaluation\n\n";
	for (vector<Predicate>::iterator it = qrs_lst.begin(); it != qrs_lst.end(); ++it) //Iterate through each query
	{
		Relation cur_rel = data.find(it->getName())->second; //Get the relation corresponding to the query
		ss << it->toString() << "? "; //Output the query being examined
		searchSelect(*it, cur_rel); //Select operation on current relation
		if (cur_rel.getList().empty()) //Tuples found?
		{
			ss << "No\n\n";
		}
		else //Yes
		{
			ss << "Yes(" << cur_rel.getList().size() << ")\n"; //Output number of tuples
			ss << "select\n" << cur_rel.toString(); //Output selected facts
			cur_rel = cur_rel.project(it->getParams()); //Project operation on select relation
			ss << "project\n" << cur_rel.toString(); //Output projected facts
			cur_rel = cur_rel.rename(it->getParams(), cur_rel); //Rename based on query variables
			data.emplace(cur_rel.getName(), cur_rel);
			ss << "rename\n" << cur_rel.toString() << "\n"; //Output renamed relation and a blank line
		}
	}
}