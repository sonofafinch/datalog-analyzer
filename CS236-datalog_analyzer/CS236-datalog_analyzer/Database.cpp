/* ---------------------------------------------------------------------------
**
** Database.cpp
** Implementation of database and functions to populate it.
** 8-3-16
** Author: Nathan Finch
** -------------------------------------------------------------------------*/

#include "Database.h"

/*
	Outputs the relations and corresponding facts, sorted by vector < operator as part
	of the set class.
*/
void Database::factOut()
{
	ss << "Fact Evaluation\n\n";
	for (std::map<std::string, Relation>::iterator it = data.begin(); it != data.end(); ++it)
	{
		ss << it->second.getName() << "\n"; //Output relation name
		ss << it->second.toString(); //Output the relation facts
		ss << "\n"; //Blank line after each relation's facts
	}
}

/*
	Takes in a list of schemes created by the Datalog Program, creating an empty relation
	for each.
*/
void Database::evalSchemes(std::vector<Predicate> schm_lst)
{
	for (vector<Predicate>::iterator it = schm_lst.begin(); it != schm_lst.end(); ++it)
	{
		Relation cur_rel;
		cur_rel.setName(it->getName()); //Predicate name becomes the relation name
		cur_rel.setScheme(it->getParams()); //Paremeters are converted to strings and set as scheme
		data.emplace(it->getName(), cur_rel); //The empty relation is added to the database
	}
	ss << "Scheme Evaluation\n\n";
}

/*
	Takes in a vector of predicate facts from the Datalog Program, iterates through
	each and adds them to the relation corresponding to the fact name.
*/
void Database::evalFacts(std::vector<Predicate> fcts_lst)
{
	for (vector<Predicate>::iterator it = fcts_lst.begin(); it != fcts_lst.end(); ++it)
	{
		data.find(it->getName())->second.addFact(it->getParams()); //Find the relation by name and add the fact as a tuple.
	}
	factOut();
}

/*
	Searches a vector of parameters to see if there are multiple entries of one value,
	recording each position in a vector.
*/
vector<int> Database::findTwo(std::vector<Parameter> prms, Parameter cur_param)
{
	std::vector<int> ind;
	int i = 0;
	for (std::vector<Parameter>::iterator it = prms.begin(); it != prms.end(); ++it)
	{
		if (it->toString() == cur_param.toString())
		{
			ind.push_back(i);
		}
		++i;
	}
	return ind;
}

/*
	Check parameters for variable or constant values and select from the current
	relation tuples that match.
*/
void Database::searchSelect(Predicate cur_pred, Relation& cur_rel)
{
	int i = 0; //Count position in list to pass to select function
	vector<Parameter> params = cur_pred.getParam(); //Get the parameters of the current predicate
	for (std::vector<Parameter>::iterator it = params.begin(); it != params.end(); ++it) //Iterate over the parameter list
	{
		if (it->isLiteral()) //Constant?
		{
			cur_rel = cur_rel.select(i, it->toString()); //Add tuples with value in current index
		}
		else //Variable
		{
			vector<int> ind = findTwo(params, *it); //Check for two of the same variable
			if (ind.size() > 1) //If variable reoccurs
			{
				cur_rel = cur_rel.select(ind[0], ind[1]); //Add tuples with matching values at given positions
			}
		}
		++i; //Increment counter
	}
	
}

/*
	Takes a vector of predicates, which are queries generated by the
	Datalog Program, as input and iterates through them to create new relations
	in the database. Each new relation is based on select, project and rename
	operations as required by the query being evaluated.
*/
void Database::evalQueries(std::vector<Predicate> qrs_lst)
{
	ss << "Query Evaluation\n\n";
	for (vector<Predicate>::iterator it = qrs_lst.begin(); it != qrs_lst.end(); ++it) //Iterate through each query
	{
		Relation cur_rel = data.find(it->getName())->second; //Get the relation corresponding to the query
		ss << it->toString() << "? "; //Output the query being examined
		searchSelect(*it, cur_rel); //Select operation on current relation
		if (cur_rel.getList().empty()) //Tuples found?
		{
			ss << "No\n\n";
		}
		else //Yes
		{
			ss << "Yes(" << cur_rel.getList().size() << ")\n"; //Output number of tuples
			ss << "select\n" << cur_rel.toString(); //Output selected facts
			cur_rel = cur_rel.project(it->getParams()); //Project operation on select relation
			ss << "project\n" << cur_rel.toString(); //Output projected facts
			cur_rel = cur_rel.rename(it->getParams()); //Rename based on query variables
			data.emplace(cur_rel.getName(), cur_rel);
			ss << "rename\n" << cur_rel.toString() << "\n"; //Output renamed relation and a blank line
		}
	}
}

/*
	Takes in a predicate and returns a relation based on its variables.
*/
Relation Database::ruleRel(Predicate cur_pred)
{
	std::vector<std::string> cur_params = cur_pred.getParams();
	Relation cur_rel = data.find(cur_pred.getName())->second; //Get the corresponding relation
	searchSelect(cur_pred, cur_rel); //Select based on rule predicate
	if (!(cur_rel.getList().empty())) //Facts found?
	{ //Yes
		cur_rel = cur_rel.project(cur_params); //Project on selected tuples
		cur_rel = cur_rel.rename(cur_pred.getParams()); //Rename based on predicate variables
	}
	return cur_rel;
}

/*
	Keep track of tuples in database to know if rules have altered any relations.
*/
int Database::countTuples()
{
	int cnt = 0;
	for (std::map<std::string, Relation>::iterator it = data.begin(); it != data.end(); ++it)
	{
		std::set<Tuple> cur_fact = it->second.getList();
		for (std::set<Tuple>::iterator jt = cur_fact.begin(); jt != cur_fact.end(); ++jt)
		{
			++cnt;
		}
	}
	return cnt;
}

/*
	Takes a vector of rules as input and iterates through them to create new relations
	in the database. Each new relation is based on select, project and rename operations
	as required by the rule being evaluated.
*/
void Database::evalRules(std::vector<Rule> rule_list)
{
	ss << "Rule Evaluation\n\n";
	int cnt = 0; 
	int passes = 0;
	do //Evaluate rules at least one time
	{
		cnt = countTuples(); //Set starting tuple count
		for (vector<Rule>::iterator it = rule_list.begin(); it != rule_list.end(); ++it) //Iterate through each rule
		{
			ss << it->toString() << "\n";
			std::vector<Relation> rule_data; //Temporary vector to save new relations
			std::vector<Predicate> cur_data = it->getData(); //Temporary vector to hold rule data
			for (std::vector<Predicate>::iterator jt = cur_data.begin(); jt != cur_data.end(); ++jt) //Iterate through each predicate
			{
				rule_data.push_back(ruleRel(*jt)); //Save relations created by rule data
			}
			while (rule_data.size() > 1) //More than one new relation?
			{
				rule_data[0] = rule_data[0].join(rule_data[1]); //Join first two relations
				rule_data.erase(rule_data.begin() + 1); //Erase the second
			} //If more than one remains, repeat
			rule_data[0] = rule_data[0].project(rule_data[0].findPos(it->getHead().getParam())); //Project on the remaining relation based on the positions found from rule head
			std::string cur_name = it->getHead().getName();
			data.at(cur_name).compFacts(rule_data[0]); //Remove anything already in the relation prior to printing out
			rule_data[0] = rule_data[0].rename(data.at(cur_name).getScheme()); //Rename based on relation
			ss << rule_data[0].toString(); //Print out prior to union
			data.at(cur_name) = data.at(cur_name).onion(rule_data[0]); //Find the relation with a matching name and union with the one from evaluation
		}
		++passes; //How many times through the rules?
	} while (cnt != countTuples()); //Repeat if any relations were altered by rules
	ss << "\nConverged after " << passes << " passes through the Rules.\n\n";
	for (std::map<std::string, Relation>::iterator it = data.begin(); it != data.end(); ++it)
	{
		ss << it->first << "\n" << it->second.toString() << "\n";
	}
}
